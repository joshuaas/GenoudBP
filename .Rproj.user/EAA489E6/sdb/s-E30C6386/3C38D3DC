{
    "contents" : "#! /usr/bin/Rscript\n  #'@description this is the general function for performance evaluation \n    performanceEval <- function(object,...) UseMethod(\"performanceEval\")\n      \n  \n   \n    #'@description dataSeparation NOTE THAT THE OUTPUT VARIABLE SHOULD BE LOCATED AT THE LAST COLUMN !!!\n    #'@description this function is used to separate the input dataset into a training set with ratio % \n    #'of the whole dataset and test set with (1 - ratio) % of the dataset \n    #'@param dataset:  the dataset to be separated\n    #'@param ratio  :  ratio of the training set size\n    #'@return this function returns a DataSep object, which includes both the input(train_x) and \n    #'desired output for training and test set respectively\n    #'@return train_x : the input of training data\n    #'@return train_y : the desired output for training data\n    #'@return test_x : the input of test data\n    #'@return test_y : the desired output for test data\n    #'@return n_out  : the number of dimensions for the output, n_out = 1 if binary classification is executed,\n    #'n_out >1 otherwise.\n    #'@return multi : indicator for whether the dataset is a multiclass classification problem \n    #'@return center : generated during data scaling ,center is a vector with each element of which being \n    #'the mean value for the coresponding variable(column)\n    #'@return std : generated during data scaling, std is a vector with each element of which being the stadard deviation\n    #'of the corresponding variable(column)\n    \n    dataSeparation  <- function(dataset,ratio = 0.85){\n        multi <- judgeMulti(dataset)\n        n_out <- 1\n        dataset <- na.omit(dataset)\n        data <- scale(dataset[,-ncol(dataset)])\n        center <- attr(data,\"scaled:center\")\n        std <- attr(data,\"scaled:scale\") \n        if(multi){\n          tar <- label2Matrix(dataset[,ncol(dataset)])\n          n_out <- ncol(tar)\n          }else{\n          tar <- as.matrix(dataset[,ncol(dataset)])\n        } \n        \n        data <- cbind(rep(1,nrow(dataset)),data)\n        force(ratio)\n        train_num  <- round(nrow(data) * 0.85)\n        index <- sample(nrow(dataset),replace=F);\n        train_x <- as.matrix(data[index[1:train_num],]);\n        train_y <- tar[index[1:train_num],];\n        test_x <- as.matrix(data[index[(train_num+1):nrow(dataset)],]);\n        test_y <- tar[index[(train_num+1):nrow(dataset)],];\n        \n        \n        structure(list(train_x =  train_x,train_y = train_y,test_x =test_x,test_y =test_y ,\n                       n_out =n_out,multi =multi,center = center,std =std ),class = \"SepData\")\n    }\n    \n    #'@description judge whether a given dataset is a multiclass dataset\n    judgeMulti  <- function(df){\n        uniq <- unique(df[, ncol(df) ])\n          if( length(uniq) == 2 && ( ( sum(uniq ==c(1,0)) ==2 ) || (sum(uniq ==c(0,1)) ==2) ) ) {\n            multi  <- F\n            n_out  <- 1\n          }else if(length(uniq) == 2){\n            stop('turn binary class into sequence of 0,1')\n            \n          }else{\n            multi  <- T\n            n_out  <- length(unique(df[,ncol(df)]))\n          }\n          multi\n    }\n    \n    # roc display function ---'----------------------------------------------------\n    #'@description : this function is used to display the roc curve for a given roc object in the input \n    #'@param roc :a roc object to be displayed\n    #'@param classLabel: the classlabel or the class name of which the roc includes\n    #'@param dataLabel :used to indicate whether a training data or a test data is used in the given roc object\n    \n    rocDisplay <- function(roc,classLabel,dataLabel){\n      plot(roc,print.auc=T,auc.polygon=TRUE, \n           max.auc.polygon=TRUE,\n           auc.polygon.col=\"skyblue\", print.thres=TRUE, main = paste(\" ROC Curve for\",classLabel,dataLabel))\n    }\n\n    #'@description : this function uses a genoudBP object to evaluate the output of a test data\n    #'@param model : a genoudBP object to be used\n    #'@param test  : a test input \n    pred.GenoudBp <- function(model,test){\n          multi = model$multi\n          test_num <- nrow(test)\n          n_out    <- model$n_out\n          n_f      <- model$n_f\n          w1_fit   <- model$w1_fit\n          w2_fit   <- model$w2_fit\n          \n        #initialize output h  multi is the indicator for whether a multiclass classification\n        #should be executed\n        \n        if(multi){\n            h  =matrix(0,nrow  = test_num,ncol = n_out)   \n          }else{\n            h=rep(0,test_num)\n            \n          }\n          \n          a1  <- rep(0,n_f)\n          lapply(1:test_num,function(i){\n            a1 <<- test[i,]\n            if(multi){\n              h[i,] <<- sigm(w2_fit%*%c(1,sigm(w1_fit%*%a1)))\n              \n            }else{\n              h[i] <<- sigm(w2_fit%*%c(1,sigm(w1_fit%*%a1)))\n              \n            }\n            \n          }\n          )\n          h\n    }\n    \n    # label to matrix-----------------------------------------------------------------------------\n    #'@description this function is used to convert a multiclass label vector into a dummy variable matrix\n    #'@details the unique class labels in the label vector will be first evaliated ,which is used generate \n    #'the binary matrix y of 0 or 1. y_ij is exactly the indicator of whether the ith sample belongs to the\n    #'jth class \n    #'@param label: the label column for your multiclassification dataset\n            \n    label2Matrix  <- function(label){\n      #calculate the number of different labels \n      type  <-  length(unique(label))\n      \n      #generate dummy matrix y\n      n <- length(label)\n      y <- matrix(0,nrow = n,ncol = type)\n      lapply(1:n,function(i){\n        y[i,] <<-as.numeric(label[i] == unique(label) )\n      })\n      \n      colnames(y) = (unique(label))\n            \n      y\n    }\n    \n    \n    #'@description : an implementaion for preformanceSEval with GenoudBP object\n    #'@param model : a genoudBP object\n    #'@param x     : input data\n    #'@param y     : output data\n    #'@seealso rocDisplay , predict.GenoudBP for more help\n    performanceEval.GenoudBP <- function(model,x,y,scaled =F,dataLabel){\n         # prediction --------------------------------------------------------------\n       \n        res   <- predict(model,x,scaled)\n        multi <- model$multi\n        n_out <- model$n_out\n        \n    ##remember to modify the roc evaluation for multiclass problem\n    if(multi){\n       \n       res_roc <- NULL\n       \n       lapply(1:n_out,function(i){\n         r  <-   roc(response = y[,i],predictor =res[,i])\n         \n         if(identical(res_roc,NULL)){\n             res_roc <<-r\n           \n            \n        \n          }else{\n            res_roc <<- list(res_roc,r)\n\n          }\n         rocDisplay(r,colnames(y)[i],dataLabel)\n         \n       })\n       \n       roc_total <- roc(response =y,predictor = res )\n       rocDisplay(roc_total,\"overall roc\",dataLabel)\n\n    }else{\n        res_roc=roc(predictor=res,response=y)\n        rocDisplay(res_roc,\"\",dataLabel)\n        \n    }\n        res_roc\n    }\n    \n    #'@description : normalize the test data with mean center and standard deviation scale\n    normalizeData <- function(center,scale,test){\n        test1 <- sweep(x = test,MARGIN = 2,FUN = '-',center)\n        test1 <- sweep(x =test1,FUN = '/',scale)\n    }   \n    \n    #'@description : a predict implementation for genoudBP object(recall that,in R, predict function is a \n    #'general function for different types of objects)\n    #'@param object : a genoudBP object to be used\n    #'@param test   : a test data\n    #'@param scaled :a logical value for  whether the test dataset is scaled.If scaled = F then the test will\n    #'be scaled according to the training data used to build the object\n    predict.GenoudBP <- function(object,test,scaled =F){\n        if(!scaled){\n            test <- normalizeData(object$center,object$scale,test)\n        }\n\n        pred.GenoudBp(object,test)\n    }\n    \n    ",
    "created" : 1420194318505.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "217054480",
    "id" : "3C38D3DC",
    "lastKnownWriteTime" : 1420196007,
    "path" : "~/GenoudBP/R/helpersForGenoud.R",
    "project_path" : "R/helpersForGenoud.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}